# 虚拟机类加载机制
## 类加载的生命周期
生命周期从类加载到虚拟机内存中开始，到从内存里卸载结束。总共包括七个阶段，分别是：加载（Loading），验证（Verification），准备（Preparation），解析（Resolution），初始化（Initialization），使用（Using），卸载（Unloading）。其中，验证，准备，解析这三个阶段统称为连接（Linking）。
### 虚拟机必须进行初始化的五种情况
#### 类加载的顺序
下列生命周期按顺序开始，注意是开始，并不一定保证什么时候完成：加载，验证，准备，初始化。 
解析操作可能穿插在初始化之后。因为解析工作可以放在初始化之后开始，例如[动态绑定]()。  


#### 必须进行初始化的几个场景。
虚拟机没有规定啥时候要进行加载环节，倒是初始化，严格规定了**有且仅有**以下5类场景，需要进行类初始化。

1. 遇到new，getstatic，putstatic，invokestatic这4条字节码指令。//三个和static有关，一个是new关键字。
2. 使用java.lang.reflect包进行反射调用，且该类尚未初始化。
3. 初始化一个类的时候，发现父类还没初始化，先触发父类初始化。
4. 当启动虚拟机时，用户指定了要执行的主类（包含Main方法的那个），虚拟机会优先初始化这个类。
5. 当使用**JDK1.7**的动态语言支持时，如果一个`java.lang.infoke.MethodHandle`实例最后解析结果是`REF_getStatic`，`REF_pubStatic`，`REF_invokeStatic`方法句柄，并且这个句柄对应的类没有进行过初始化，则先触发其初始化。

## 类加载的过程
类加载包括了加载，验证，准备，解析，初始化这五个阶段。
### 加载
这里的加载时类加载的一个阶段，主要完成的事情有下列三个：

1. 通过一个类的**全限定名称**来获取类的二进制字节流。
2. 将字节流代表的静态存储结构转化为方法区的运行时数据结构。
3. 内存中生成一个代表这个类的java.lang.Class，作为方法去这个类各个数据的访问入口。

类加载途径在虚拟机规范中没有做限制，因此多种加载的技术，例如:

1. 基于ZIP,WAR,JAR,EAR等格式的压缩包中读取。
2. 从网络中获取，例如Applet。
3. 运行时计算生成，例如动态代理技术，生成“$Proxy”形式的代理类二进制字节流。
4. 由其他文件生成，例如JSP技术，用JSP文件生成Class类。
5. 从数据库中读取。

......

类加载区分数组类和非数组类。对于非数组类的类加载，程序员操作性最强，可以使用同提供的引导类加载器进行加载，也可以采用自定义类加载器。而数组类的类加载，数组类本身并不通过类加载器进行加载，由虚拟机直接创建。而对于数组里的元素类型，最终还是要依靠类加载器去加载的。

数组类的创建规则如下：

1. 如果数组去掉一维的类型（又称为数组的组件类型）为引用类型，例如Integer，Long或者自定义的类型，那就**递归**采用系统提供的引导类加载器或者自定义类加载器去加载这个组件类型。数组将在加载该**组件类型**的类加载器的类命名空间上被标识。//这段有点难懂
2. 如果数组去掉一维的类型不是引用类型，而是基本类型，例如`int[]`类型的数组，那么虚拟机将会将数组标记为与引导类加载器关联。
3. 数组类的可见性和组件类型的可见性一致，如果组件类型为非引用类型，那么数组类的可见性默认为public。//这一句有点难懂。

### 验证
验证阶段用于确保Class文件中的字节流包含的信息符合当前虚拟机的要求，不会危害到虚拟机的安全。大致分为四个阶段：

1. 文件格式验证。
2. 元数据验证。
3. 字节码验证。
4. 符号引用验证。

#### 文件格式验证
验证字节流是否符合Class文件格式的规范，且能够被当前虚拟机处理。  
例如，字节码是否已魔数OxCAFEBABE开头；主次版本是否能被当前虚拟机处理；常量池是否有不支持的常量；指向常量标的索引是否存在不存在的常量或者不符合类型的常量；CONSTANT_Uft8_info类型的长两种是否有不符合UTF8编码的数据等等。

#### 元数据验证
元数据验证是对字节码的描述做语义分析，保证其描述符合Java语言规范的要求。 可能包括的验证点如下： 

* 加载的类是否存在父类。
* 父类是否继承了不允许继承的类。
* 抽象类是否实现了父类抽象类或者接口要求实现的所有方法。
* 字段，方法是否存在与父类矛盾，例如覆盖父类的final方法，或是采用了非法的重载，比如方法的参数均相同但仅仅返回值不同等等。

#### 字节码验证
通过数据流和控制流的分析，确保程序语义是合法，符合逻辑的。和元数据验证的不同是**这个阶段将对方法体进行校验**，确保方法在运行时不会危害到虚拟机。这一阶段也是最复杂的。  
例如保证一个操作栈中存放的一个int类型的数据，使用时不会以long类型加载到本地变量表；保证跳转指令不会跳转到方法体以外的字节码指令；保障方法体中的类型转换时有效的。

**通过字节码验证的类方法不能代表一定是安全的，但是类方法没能通过字节码验证，那一定是有问题的。**

为了避免字节码验证消耗过多的时间，JDK1.6之后采用检查“StackMapTable”属性表来避免进行类型的推导。JDK1.7之前，可以存在字节码类型推导和查表法共存，但JDK1.7之后只支持查表完成数据流分析校验。

#### 符号引用验证
符号引用验证发生在符号引用转换成直接引用的时候。转化操作在类加载的**解析阶段**完成。验证的意义就在于保证解析动作能够正常执行。  
例如，符号引用中通过字符串描述的全限定名是否能找到对应的类；类、字段、方法的访问性，是否可以被当前类访问。

> 符号引用

对于类加载机制而言，验证阶段是非常重要，但不是一定必须要的。因为其本身对程序运行期没有影响。如果能够保证全部代码是OK的，可以通过`-Xverify：none`参数来关闭大部分验证措施。

### 准备
准备阶段做的工作是为**类变量**分配内存并赋初始值。注意这里是类变量（被static修饰的变量），不包括实例变量。实例变量在类初始化的时候分配内存。

例如：

```java
public static int value = 123;
```

准备阶段过了以后value的值是0，而不是123。value想变成123是初始化阶段才会执行。  

基本数据表的零值见下面表格：

|数据类型|零值|
| :---: | :---: |
|int|0|
|long|0L|
|short|(short)0|
|char|'\u0000'|
|byte|(byte)0|
|boolean|false|
|float|0.0f|
|double|0.0d|
|reference|null|

例外：如果类变量的字段属性表存在ConstantValue属性，则准备阶段就会初始化城ConstantValue指定的值，例如：

```java
public static final int value = 123;
```

该代码在准备阶段value即被赋值成了123。

### 解析
解析阶段的任务是将常量池里的**符号引用**替换为**直接引用**。