1、查找分为静态查找和动态查找。
静态查找：待查找集合是不变的。
动态查找：待查找集合会动态改变。

静态查找的方法：
有一种程序设计的技巧，叫做哨兵。
在查找元素的过程中，我们一般要做两个判断。1、是否能够查找到元素，

判定树：
在分析活动中，用树形逻辑图对单个功能和活动进行详细的分析。
二分查找就是一种典型的引用。判定树上查找的次数不会超过判定树的**深度**。n个结点的判定树的深度为[log2n]+1。平均成功查找次数为ASL=(4*4+4*3+2*2+1)/11=3

由于在树里面插入和删除结点，比在数组里面容易的多。因此树可以较好的解决动态查找问题。

树的的性质。
1、树中有一个称为根的特殊结点。
2、其余结点尅分为m个互不相交的有限集合T1,T2...Tm，其中每个集合本身又是一棵树，称为原来树的子树。

基本概念：
1、结点的度：结点子树的个数。
2、树的度：树中所有结点中最大的度。
3、路径和路径长度：结点n1到nk经过的所有结点序列（n1,n2....nk）为路径，路径中包含的边的数量就是路径长度。
4、祖先结点。对于一个结点而言，从根节点到这个结点路径上所有的结点都是这个结点的祖先结点。
5、子孙结点：某一个结点的所有子树就是这个结点的子孙。
6、结点的层次：根节点在1层，其他任何结点层次都是其父节点层数+1。
7、树的深度：树中所有结点的最大层次，就是这棵树的深度。

树的表示：
1、树用数组来表示难度还是比较大的。因为树形态多变，光看数组中的元素很难看出父亲节点和子节点的关系。
2、用链表来表示。但是如果每个节点的结构迥异，比如A节点有3个子节点，B节点有2个子节点，那设计的时候其实难度也是比较大。如果规定每个节点都拥有相同的数据结构，则又可能造成节点空间的浪费（比如均涉及为3个子节点）。
比较好的办法是儿子兄弟表示法。左边的指针表示第一个儿子，右边的指针指向它的兄弟。
通过树的性质可以知道，如果有N个节点，那么就有N-1条边。由于儿子兄弟表示法，每个节点有2个指针域，意味着N-1个指针域是非空的，而N+1个指针域为空。
儿子兄弟表示法，如果旋转45%，可以看到每个节点最多有俩指针，一个指向左边，一个指向右边，这种表示就是二叉树。二叉树就是度为2的树，也就是一般的树都可以用儿子兄弟表示法，转化成二叉树的形式。所以二叉树是树结构研究中最重要和最主要的部分。

二叉树：
一个有穷的结点集合。集合可以为空。如果集合不为空，根节点可以有左子树和右子书，子树有左右之分。

特殊二叉树：
斜二叉树：顾名思义，一条斜的，只有左儿子或者。
满二叉树或者完美二叉树：除了叶子结点以外，其他结点都有两个儿子。并且所有的叶子节点都处在最底层。
完全二叉树：除了叶子节点那一层，上面是个满二叉树，叶子节点按顺序排过来，可以缺几个。也就是除了缺的哪几个叶子，节点编号按顺序过来和满二叉树是完全一致的。

二叉树的重要性质：
二叉树的第i层，最大可以有2^(i-1)，i>=1
深度为k的二叉树最大节点，最大的节点总数为(2^k)-1
任何非空的二叉树，n0表示叶子n1表示有一个节点，n2表示有两个儿子，n0=n2+1；这个公式很好证明，从上往下看，边的数量为n0+n1+n2-1；从上往下看，边的数量是0*n0+1*n1+2*n2；0*n0+1*n1+2*n2=n0+n1+n2-1；因此n0=n2+1;

二叉树重要的操作集：
1、isEmpty判断二叉树是否为空
2、Traversal，遍历，按顺序遍历每个节点。对二叉树来讲，最重要的是遍历。很多算法都是建立在遍历树，很多时候只要知道怎么把树的元素看一遍，就能构造出很多算法。
3、CreateBinaryTree创建一个二叉树。

树的表示：
1、完全二叉树可以用数组进行表示。一般二叉树也可以，但是会造成空间浪费。

常用的遍历方法有：
1、先序遍历
2、中序遍历
3、后序遍历
4、层次遍历：从上到下，从左到右。也就是一层一层地看。

二叉树的存储结构：
一般树用数组来表示很困难，但是二叉树分支较少。有一种二叉树用数组表示非常方便，那就是完全二叉树。
对于任何一个非根节点，父节点的序号是[i/2]取下。
一般的二叉树也可用数组来存储，但是会留下很多空位。

因此一般的二叉树还是采用链表存储。

先序遍历，中序遍历和后续遍历所经过的路径是一样的，只不过打印结点的时机并不一样。

二叉树的非递归遍历：

中序遍历的非递归算法：



二叉树遍历的本质：是怎样把二维的结构变成一个一维的结构。二维结构的线性化。

在访问的过程中，通过父节点，来访问其左儿子和右儿子，如果父节点忘记了，又访问了左儿子，那就永远访问不到右儿子了。

那访问了左儿子以后，右儿子怎么办？
需要一个存储结构保存暂时不访问的节点
存储结构：堆栈、队列。

队列法：1、将根节点放入队列。2、抛出元素，访问该元素。3、将不用的孩子放到队列当中。
