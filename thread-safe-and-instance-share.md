# 线程安全与共享

## 什么是线程安全
其实线程安全这个概念很难定义，定义越正式，包含的内容就越复杂。不过在安全性定义中，最核心的一个概念是正确性。

正确性的概念：类的行为与其规范完全一致。即（在单线程情况下）类代码按照我们的预期进行工作。如果有多个线程访问某个类，这个类始终表现出正确的行为，就称为类是线程安全的。

> 当多个线程访问某个类，不管运行时环境如何调度，线程如何交替执行。如果在主调代码中**不需要任何额外的同步或协同**，类都能表现正确的行为，称类就是线程安全的。

编写线程安全的代码，核心其核心就在于对状态访问操作进行管理，特别是对共享的和可变的状态进行访问。

## 竞态条件和原子性
所谓的竞态条件，就是由于不恰当的执行顺序导致出现不正确结果的情况。

想要避免竞态条件，**就必须在某个线程修改某个变量的时候，通过某个方式防止其他线程使用到这个变量**。这样其他线程修改或读取的状态，是一个已经已由“某个线程”完成修改操作了的状态，而不是一个正在修改中的状态。

## 对象共享带来的问题
多个线程直接对共享变量进行读写，为了保证操作的正确性，需要达到以下两种状态：

1. 防止两个线程在读取使用对象状态的同时而另一个线程同时在使用。
2. 一个线程修改共享变量的状态后，另一个线程能够立即看到共享变量发生的变化。

很遗憾按照Java的内存模型，如果不采用同步措施，共享变量被修改以后，另一个线程并不能马上看到被修改的值。这就是对象的可见性问题。

### 可见性问题
在没有任何同步措施的情况下，一个线程对共享变量进行操作，不能保证其他线程啥时候能看到变量被修改后的值。也许能立即看见新的值，也许很长时间只能看到一个较老的值。这是由于Java的编译器，处理器均可能对Java的执行指令进行重排序。对于共享变量的写入，写入的值会先放到线程缓存上，再刷入共享变量的内存中。如果值在某个线程的缓存上，那对其他线程而言自然是不可见的。关于指令重排序的问题，可以参考另一篇关于指令重排的文章。

### 解决对象可见性问题的几种手段

#### 1. volatile关键字
将共享变量申明为`volatile`（PS：意为共享变量）。申明为volatile的值，不会与其他内存操作一起重排，不会写入到寄存器或者其他处理器不可见的地方。

volatile关键字能保证内存可见性问题（改了其他线程马上能知道），但是没有办法保证某个操作的原子性。例如下面操作，尤其是下面的操作，需要特别小心。

```java
volatile int count=0;

...

void add(){
counter++;
}
```

由于add操作中的++操作在指令层面上会被拆分多层指令，所以add并不是一个原子操作，会导致竞态条件。

因此当且仅当满足以下条件，才应该使用volatile：

#### 2. 加锁
加锁能够保证两个事情：1、互斥。能够保证加锁区域的操作是原子操作。2、内存可见，保证加锁区域的操作在操作结束后一定可以被其他线程看到。

#### 3. 防止逸出
说到逸出，首先要聊聊对象的发布“Publish”。所谓的发布，就是指对象能够在当前的作用域之外被引用到。举个例子，例如讲一个指向对象的引用，保存到一个容器当中，然后被另一个代码块使用。或是一个私有的变量，能够通过一个